% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/peak_finding.R
\name{correct_peak}
\alias{correct_peak}
\title{Manually Correct Single Peak}
\usage{
correct_peak(
  df.peaks,
  df.data,
  measurement,
  peak,
  additional.msecs,
  path.data = NULL
)
}
\arguments{
\item{df.peaks}{The resulting tibble of the function \code{find_peaks()}. See \code{?find_peaks} for more details.}

\item{df.data}{A data frame or tibble in the below format. The columns \code{t} (time), \code{force}, \code{measurement}, and \code{specimen}.
(measurement ID) must be present. This will usually be the same table that was used before in \code{find_peaks()}.}

\item{measurement}{A character string defining the measurement ID (e.g. measurement number) of the peak to be corrected. Must be congruent with the
respective measurement ID within \code{df.peaks} and \code{df}.}

\item{peak}{A numerical value defining the peak to be corrected.}

\item{additional.msecs}{A numerical value defining the time before and after the originally defined window of the peak to be corrected. Higher
values allow defining start and end points further away from the original start and end points.
@param path.data A string character defining where to save the result and log file. If \code{NULL} (default),
data is not stored in files. Log files cannot be retrieved in this case.}

\item{path.data}{A string character defining where to save the results. If \code{NULL} (default),
data is not stored in a file.}
}
\value{
Changes values within \code{df.peaks} and returns the changed tibble.
}
\description{
Interactive correction of a single peak.
}
\details{
When running the function, you will be prompted to select the actual start and end of the current \code{peak} of the current \code{measurement}. If more or less
than exactly 2 points are defined, the process is terminated.
}
\section{\code{df} needs to contain the following columns:}{
\tabular{ccc}{
   \strong{\code{t}} \tab \strong{\code{force}} \tab \strong{\code{measurement}} \cr
   \code{t.1} \tab \code{force.1} \tab \code{measurement.1} \cr
   \code{...} \tab \code{...} \tab \code{...} \cr
   \code{t.n} \tab \code{force.n} \tab \code{measurement.m} \cr
}
}

\examples{
require(dplyr)

# PREPARATION ####
# create a classifier to store specimen info (see package vignette for details)
classifier <- tibble(species = c("A","A","A","A","B","B","B","B"),
                     specimen = c("a","a","b","b","c","c","d","d"),
                     measurement = paste0("m_0", 1:8),
                     amp = c(rep(2,4), rep(0.5, 4)),
                     lever.ratio = rep(0.5, 8))

# create temporary tibble to store data for bite series simulation
classifier.temp <- classifier \%>\%
  mutate(type = c(rep("sin", 4), rep("plat", 4)),
         max.y = c(1.9, 2.4, 2.2, 2.0, 6.8, 7.2, 7.5, 7.2),
         length.of.bite = c(20, 20, 18, 22, 50, 40, 45, 40),
         length.of.series = c(rep(200, 4), rep(600, 4)),
         jit = c(rep(0.5, 4), rep(1, 4)))

# create tibble with eight simulated time series with different
# bite characteristics for each measurement, specimen and species
df.all <- NULL
for(i in 1:nrow(classifier.temp)){
  df.curr <- simulate_bites(no.of.bites = 7,
                            length.of.bite = classifier.temp$length.of.bite[i],
                            length.of.series = classifier.temp$length.of.series[i],
                            max.y = classifier.temp$max.y[i],
                            max.y.jit = 15,
                            jit = classifier.temp$jit[i],
                            bite.type = classifier.temp$type[i],
                            plot = FALSE)

  # add measurement number to df.curr
  df.curr <- df.curr \%>\%
    mutate(measurement = classifier.temp$measurement[i])

  # add current sumulated bite series to df.all
  df.all <- rbind(df.all, df.curr)
}
# remove temporary tibble to avoid confusion
rm(classifier.temp)

# rename columns
df.all <- df.all \%>\%
  rename(force = y)

# add classifier info to bite table (df.all)
df.all <- left_join(df.all,
                    classifier,
                    by = "measurement")

peaks.df <- find_strongest_peaks(df = df.all,
                                 no.of.peaks = 5,
                                 print.to.pdf = FALSE)

plot_peaks(df.peaks = peaks.df,
           df.data = df.all,
           additional.msecs = 20,
           print.to.pdf = FALSE)

# RUNNING THE FUNCTION ####
\dontrun{
# This function needs user input.
peaks.df <- correct_peak(df.peaks = peaks.df,
                        df.data = df.all,
                        measurement = "m_02",
                        peak = 1,
                        additional.msecs = 5)
}
}
